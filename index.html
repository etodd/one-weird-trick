<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>One Weird Trick to Write Better Code</title>

		<meta name="description" content="Developers hate him!">
		<meta name="author" content="Evan Todd">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="reveal.js/css/reveal.css">
		<link rel="stylesheet" href="style.css" id="theme">
	</head>

	<body>
		<div class="reveal">
			<div class="slides">
				<section data-background="#101a26">
					<h1>One Weird Trick to Write Better Code</h1>
					<small>
						Evan Todd<br />
						(developers hate him!)<br />
						&#8592;&#8594;
					</small>
				</section>
				<section data-background="#158">
					<h1>In search of the One Weird Trick</h1>
					<p>I'll talk about a lot of tricks...</p>
					<p>But we're looking for the One Weird Trick to rule them all</p>
					<aside class="notes">
						<ul>
							<li>I really like clickbait headlines</li>
							<li>So powerful that it extends beyond programming</li>
							<li>Actually saved my parents marriage</li>
							<li>Just kidding, they're still divorced</li>
						</ul>
					</aside>
				</section>
				<section data-background="#101a26">
					<h1>Start at the beginning</h1>
					<img src="img/ninjawars.png" />
				</section>
				<section data-background="#101a26">
					<h1>We've all been here</h1>
					<pre><code data-trim class="javascript">
var x = 314;
var y = 8;
var prevy= 1;
var prevx= 1;
var prevsw= 0;
var row= 304;
var endrow= 142;
var sword= 296;
var yrow = 0;
var yendrow = 186;
var I = 0;
var e = 0;
var counter = 0;
var found = 0;
var esword = 26;
var eprevsw = 8;
var bluehealth = 40;
var redhealth = 40;
var n = 0;
var you = 'ninja';
var bullet = 'sword';
var enemy = 'enemy';
var ebullet = 'enemysword';
var besieged = 0;
var siegecount = 0;
var esiegecount = 0;
var ebesieged = 0;
var healthcount = 0;
var player = 0;
var starcount = 0;
var infortress = false;
var prevyou = you;
var einfortress = false;
var prevenemy = enemy;
var previmg = "";
var prevbullet= "";
var eprevbullet= "";
var randnum = 0;
var randnum2 = 0;
var randnum3 = 0;
var randnum4 = 0;
var buildcount = 0;
var characters = new Array(4);
characters = ['ninja','tank','heli','builder'];
var bullets = new Array(3);
bullets = ['sword','bullet','5cal','sword'];
var echaracters = new Array(3);
echaracters = ['enemy','tank2','eheli','ebuilder'];
var ebullets = new Array(3);
ebullets = ['enemysword','bullet2','e5cal','enemysword'];
var health = new Array(4);
health = [40,30,20,10];
var prevorb = 0;
var prevnum = 0;
					</code></pre>
				</section>
				<section data-background="#185">
					<h1>Trick #1</h1>
					<p>Don't use globals</p>
					<aside class="notes">
						<p>Spaghetti code</p>
					</aside>
				</section>
				<section data-background="#101a26">
					<h1>Trick #2: object-oriented to the rescue!</h1>
					<pre><code data-trim class="csharp">
class Ninja
{
	int x, y;
	int previousX, previousY;
	int health = 100;
}

class Sword
{
	int x, y;
	int previousX, previousY;
	int sharpness = 9000;
}
					</pre></code>
					<aside class="notes">
						<p>Can have multiple instances of objects</p>
					</aside>
				</section>
				<section data-background="#101a26">
					<h1>We can even do this</h1>
					<pre><code data-trim class="csharp">
class Movable
{
	int x, y;
	int previousX, previousY;
}

class Ninja : public Movable
{
	int health = 100;
}

class Sword : public Movable
{
	int sharpness = 9000;
}
					</code></pre>
					<aside class="notes">
						<p>Extract common code</p>
					</aside>
				</section>
				<section data-background="#158">
					<h1>Classic game code</h1>
					<p>
						Doom 3 source - <a href="https://github.com/id-Software/DOOM-3-BFG">github.com/id-Software/DOOM-3-BFG</a>
					</p>
					<ul class="blank">
						<li>idClass
						<ul class="blank">
							<li>idEntity
							<ul class="blank">
								<li>idAnimatedEntity
								<ul class="blank">
									<li>idWeapon</li>
									<li>idAFEntity_Base
									<ul class="blank">
										<li>idAFEntity_ClawFourFingers</li>
										<li>idAFEntity_Vehicle
										<ul class="blank">
											<li>idAFEntity_VehicleFourWheels</li>
											<li>idAFEntity_VehicleSixWheels</li>
										</ul>
										</li>
										<li>idAFEntity_Gibbable
										<ul class="blank">
											<li>idAFEntity_WithAttachedHead</li>
											<li>idActor
											<ul class="blank">
												<li>idPlayer</li>
												<li>idAI</li>
											</ul>
										</ul>
										</li>
									</ul>
									</li>
								</ul>
								</li>
							</ul>
							</li>
						</ul>
						</li>
					</ul>
					<aside class="notes">
						<ul>
							<li>Actually a beautiful codebase</li>
							<li>Classic OOP design</li>
						</ul>
					</aside>
				</section>
				<section data-background="#822">
					<h1>Problem</h1>
					<p>"The player is now a car"</p>
					<ul>
						<li>idClass
						<ul class="blank">
							<li>idEntity
							<ul class="blank">
								<li>idAnimatedEntity
								<ul class="blank">
									<li>idWeapon</li>
									<li>idAFEntity_Base
									<ul class="blank">
										<li>idAFEntity_ClawFourFingers</li>
										<li>idAFEntity_Vehicle
										<ul class="blank">
											<li>idAFEntity_VehicleFourWheels <span class="fragment">&lt;------------</span></li>
											<li>idAFEntity_VehicleSixWheels</li>
										</ul>
										</li>
										<li>idAFEntity_Gibbable
										<ul class="blank">
											<li>idAFEntity_WithAttachedHead</li>
											<li>idActor
											<ul class="blank">
												<li>idPlayer <span class="fragment">&lt;------------</span></li>
												<li>idAI</li>
											</ul>
										</ul>
										</li>
									</ul>
									</li>
								</ul>
								</li>
							</ul>
							</li>
						</ul>
						</li>
					</ul>
					<aside class="notes">
						<ul>
							<li>Assignment from John Carmack</li>
							<li>"Easy, make the player <em>control</em> the car instead of <em>being</em> the car."</li>
						</ul>
					</aside>
				</section>
				<section data-background="#622">
					<h1>More subtle but dangerous problem</h1>
					<p>"Some code needs to go in both VehicleFourWheels and idPlayer"</p>
					<ul class="fragment">
						<li>idClass
						<ul class="blank">
							<li>idEntity
							<ul class="blank">
								<li>idAnimatedEntity
								<ul class="blank">
									<li>idWeapon</li>
									<li>idAFEntity_Base <span class="fragment">&lt;------------------ right here. perfect.</span>
									<ul class="blank">
										<li>idAFEntity_ClawFourFingers</li>
										<li>idAFEntity_Vehicle
										<ul class="blank">
											<li>idAFEntity_VehicleFourWheels &lt;------------</li>
											<li>idAFEntity_VehicleSixWheels</li>
										</ul>
										</li>
										<li>idAFEntity_Gibbable
										<ul class="blank">
											<li>idAFEntity_WithAttachedHead</li>
											<li>idActor
											<ul class="blank">
												<li>idPlayer &lt;------------</li>
												<li>idAI</li>
											</ul>
										</ul>
										</li>
									</ul>
									</li>
								</ul>
								</li>
							</ul>
							</li>
						</ul>
						</li>
					</ul>
					<aside class="notes">
						<ul>
							<li>Example: network sync functionality</li>
							<li>Too lazy to copy/paste</li>
						</ul>
					</aside>
				</section>
				<section data-background="#101a26">
					<h1>The terrible, logical conclusion</h1>
						<pre><code data-trim class="cpp">
class idEntity : public idClass {
public:
	static const int		MAX_PVS_AREAS = 4;
	static const uint32		INVALID_PREDICTION_KEY = 0xFFFFFFFF;

	int						entityNumber;			// index into the entity list
	int						entityDefNumber;		// index into the entity def list

	idLinkList&lt;idEntity&gt;	spawnNode;				// for being linked into spawnedEntities list
	idLinkList&lt;idEntity&gt;	activeNode;				// for being linked into activeEntities list
	idLinkList&lt;idEntity&gt;	aimAssistNode;			// linked into gameLocal.aimAssistEntities

	idLinkList&lt;idEntity&gt;	snapshotNode;			// for being linked into snapshotEntities list
	int						snapshotChanged;		// used to detect snapshot state changes
	int						snapshotBits;			// number of bits this entity occupied in the last snapshot
	bool					snapshotStale;			// Set to true if this entity is considered stale in the snapshot

	idStr					name;					// name of entity
	idDict					spawnArgs;				// key/value pairs used to spawn and initialize entity
	idScriptObject			scriptObject;			// contains all script defined data for this entity

	int						thinkFlags;				// TH_? flags
	int						dormantStart;			// time that the entity was first closed off from player
	bool					cinematic;				// during cinematics, entity will only think if cinematic is set

	renderView_t *			renderView;				// for camera views from this entity
	idEntity *				cameraTarget;			// any remoteRenderMap shaders will use this

	idList&lt; idEntityPtr&lt;idEntity&gt;, TAG_ENTITY &gt;	targets;		// when this entity is activated these entities entity are activated

	int						health;					// FIXME: do all objects really need health?

	struct entityFlags_s {
		bool				notarget			:1;	// if true never attack or target this entity
		bool				noknockback			:1;	// if true no knockback from hits
		bool				takedamage			:1;	// if true this entity can be damaged
		bool				hidden				:1;	// if true this entity is not visible
		bool				bindOrientated		:1;	// if true both the master orientation is used for binding
		bool				solidForTeam		:1;	// if true this entity is considered solid when a physics team mate pushes entities
		bool				forcePhysicsUpdate	:1;	// if true always update from the physics whether the object moved or not
		bool				selected			:1;	// if true the entity is selected for editing
		bool				neverDormant		:1;	// if true the entity never goes dormant
		bool				isDormant			:1;	// if true the entity is dormant
		bool				hasAwakened			:1;	// before a monster has been awakened the first time, use full PVS for dormant instead of area-connected
		bool				networkSync			:1; // if true the entity is synchronized over the network
		bool				grabbed				:1;	// if true object is currently being grabbed
		bool				skipReplication		:1; // don't replicate this entity over the network.
	} fl;

	int						timeGroup;

	bool					noGrab;

	renderEntity_t			xrayEntity;
	qhandle_t				xrayEntityHandle;
	const idDeclSkin *		xraySkin;

	void					DetermineTimeGroup( bool slowmo );

	void					SetGrabbedState( bool grabbed );
	bool					IsGrabbed();

public:
	ABSTRACT_PROTOTYPE( idEntity );

							idEntity();
							~idEntity();

	void					Spawn();

	void					Save( idSaveGame *savefile ) const;
	void					Restore( idRestoreGame *savefile );

	const char *			GetEntityDefName() const;
	void					SetName( const char *name );
	const char *			GetName() const;
	virtual void			UpdateChangeableSpawnArgs( const idDict *source );
	int						GetEntityNumber() const { return entityNumber; }

							// clients generate views based on all the player specific options,
							// cameras have custom code, and everything else just uses the axis orientation
	virtual renderView_t *	GetRenderView();

	// thinking
	virtual void			Think();
	bool					CheckDormant();	// dormant == on the active list, but out of PVS
	virtual	void			DormantBegin();	// called when entity becomes dormant
	virtual	void			DormantEnd();		// called when entity wakes from being dormant
	bool					IsActive() const;
	void					BecomeActive( int flags );
	void					BecomeInactive( int flags );
	void					UpdatePVSAreas( const idVec3 &amp;pos );
	void					BecomeReplicated();

	// visuals
	virtual void			Present();
	virtual renderEntity_t *GetRenderEntity();
	virtual int				GetModelDefHandle();
	virtual void			SetModel( const char *modelname );
	void					SetSkin( const idDeclSkin *skin );
	const idDeclSkin *		GetSkin() const;
	void					SetShaderParm( int parmnum, float value );
	virtual void			SetColor( float red, float green, float blue );
	virtual void			SetColor( const idVec3 &amp;color );
	virtual void			GetColor( idVec3 &amp;out ) const;
	virtual void			SetColor( const idVec4 &amp;color );
	virtual void			GetColor( idVec4 &amp;out ) const;
	virtual void			FreeModelDef();
	virtual void			FreeLightDef();
	virtual void			Hide();
	virtual void			Show();
	bool					IsHidden() const;
	void					UpdateVisuals();
	void					UpdateModel();
	void					UpdateModelTransform();
	virtual void			ProjectOverlay( const idVec3 &amp;origin, const idVec3 &amp;dir, float size, const char *material );
	int						GetNumPVSAreas();
	const int *				GetPVSAreas();
	void					ClearPVSAreas();
	bool					PhysicsTeamInPVS( pvsHandle_t pvsHandle );

	// animation
	virtual bool			UpdateAnimationControllers();
	bool					UpdateRenderEntity( renderEntity_s *renderEntity, const renderView_t *renderView );
	static bool				ModelCallback( renderEntity_s *renderEntity, const renderView_t *renderView );
	virtual idAnimator *	GetAnimator();	// returns animator object used by this entity

	// sound
	virtual bool			CanPlayChatterSounds() const;
	bool					StartSound( const char *soundName, const s_channelType channel, int soundShaderFlags, bool broadcast, int *length );
	bool					StartSoundShader( const idSoundShader *shader, const s_channelType channel, int soundShaderFlags, bool broadcast, int *length );
	void					StopSound( const s_channelType channel, bool broadcast );	// pass SND_CHANNEL_ANY to stop all sounds
	void					SetSoundVolume( float volume );
	void					UpdateSound();
	int						GetListenerId() const;
	idSoundEmitter *		GetSoundEmitter() const;
	void					FreeSoundEmitter( bool immediate );

	// entity binding
	virtual void			PreBind();
	virtual void			PostBind();
	virtual void			PreUnbind();
	virtual void			PostUnbind();
	void					JoinTeam( idEntity *teammember );
	void					Bind( idEntity *master, bool orientated );
	void					BindToJoint( idEntity *master, const char *jointname, bool orientated );
	void					BindToJoint( idEntity *master, jointHandle_t jointnum, bool orientated );
	void					BindToBody( idEntity *master, int bodyId, bool orientated );
	void					Unbind();
	bool					IsBound() const;
	bool					IsBoundTo( idEntity *master ) const;
	idEntity *				GetBindMaster() const;
	jointHandle_t			GetBindJoint() const;
	int						GetBindBody() const;
	idEntity *				GetTeamMaster() const;
	idEntity *				GetNextTeamEntity() const;
	void					ConvertLocalToWorldTransform( idVec3 &amp;offset, idMat3 &amp;axis );
	idVec3					GetLocalVector( const idVec3 &amp;vec ) const;
	idVec3					GetLocalCoordinates( const idVec3 &amp;vec ) const;
	idVec3					GetWorldVector( const idVec3 &amp;vec ) const;
	idVec3					GetWorldCoordinates( const idVec3 &amp;vec ) const;
	bool					GetMasterPosition( idVec3 &amp;masterOrigin, idMat3 &amp;masterAxis ) const;
	void					GetWorldVelocities( idVec3 &amp;linearVelocity, idVec3 &amp;angularVelocity ) const;

	// physics
							// set a new physics object to be used by this entity
	void					SetPhysics( idPhysics *phys );
							// get the physics object used by this entity
	idPhysics *				GetPhysics() const;
							// restore physics pointer for save games
	void					RestorePhysics( idPhysics *phys );
							// run the physics for this entity
	bool					RunPhysics();
							// Interpolates the physics, used on MP clients.
	void					InterpolatePhysics( const float fraction );
							// InterpolatePhysics actually calls evaluate, this version doesn't.
	void					InterpolatePhysicsOnly( const float fraction, bool updateTeam = false );
							// set the origin of the physics object (relative to bindMaster if not NULL)
	void					SetOrigin( const idVec3 &amp;org );
							// set the axis of the physics object (relative to bindMaster if not NULL)
	void					SetAxis( const idMat3 &amp;axis );
							// use angles to set the axis of the physics object (relative to bindMaster if not NULL)
	void					SetAngles( const idAngles &amp;ang );
							// get the floor position underneath the physics object
	bool					GetFloorPos( float max_dist, idVec3 &amp;floorpos ) const;
							// retrieves the transformation going from the physics origin/axis to the visual origin/axis
	virtual bool			GetPhysicsToVisualTransform( idVec3 &amp;origin, idMat3 &amp;axis );
							// retrieves the transformation going from the physics origin/axis to the sound origin/axis
	virtual bool			GetPhysicsToSoundTransform( idVec3 &amp;origin, idMat3 &amp;axis );
							// called from the physics object when colliding, should return true if the physics simulation should stop
	virtual bool			Collide( const trace_t &amp;collision, const idVec3 &amp;velocity );
							// retrieves impact information, 'ent' is the entity retrieving the info
	virtual void			GetImpactInfo( idEntity *ent, int id, const idVec3 &amp;point, impactInfo_t *info );
							// apply an impulse to the physics object, 'ent' is the entity applying the impulse
	virtual void			ApplyImpulse( idEntity *ent, int id, const idVec3 &amp;point, const idVec3 &amp;impulse );
							// add a force to the physics object, 'ent' is the entity adding the force
	virtual void			AddForce( idEntity *ent, int id, const idVec3 &amp;point, const idVec3 &amp;force );
							// activate the physics object, 'ent' is the entity activating this entity
	virtual void			ActivatePhysics( idEntity *ent );
							// returns true if the physics object is at rest
	virtual bool			IsAtRest() const;
							// returns the time the physics object came to rest
	virtual int				GetRestStartTime() const;
							// add a contact entity
	virtual void			AddContactEntity( idEntity *ent );
							// remove a touching entity
	virtual void			RemoveContactEntity( idEntity *ent );

	// damage
							// returns true if this entity can be damaged from the given origin
	virtual bool			CanDamage( const idVec3 &amp;origin, idVec3 &amp;damagePoint ) const;
							// applies damage to this entity
	virtual	void			Damage( idEntity *inflictor, idEntity *attacker, const idVec3 &amp;dir, const char *damageDefName, const float damageScale, const int location );
							// adds a damage effect like overlays, blood, sparks, debris etc.
	virtual void			AddDamageEffect( const trace_t &amp;collision, const idVec3 &amp;velocity, const char *damageDefName );
							// callback function for when another entity received damage from this entity.  damage can be adjusted and returned to the caller.
	virtual void			DamageFeedback( idEntity *victim, idEntity *inflictor, int &amp;damage );
							// notifies this entity that it is in pain
	virtual bool			Pain( idEntity *inflictor, idEntity *attacker, int damage, const idVec3 &amp;dir, int location );
							// notifies this entity that is has been killed
	virtual void			Killed( idEntity *inflictor, idEntity *attacker, int damage, const idVec3 &amp;dir, int location );

	// scripting
	virtual bool			ShouldConstructScriptObjectAtSpawn() const;
	virtual idThread *		ConstructScriptObject();
	virtual void			DeconstructScriptObject();
	void					SetSignal( signalNum_t signalnum, idThread *thread, const function_t *function );
	void					ClearSignal( idThread *thread, signalNum_t signalnum );
	void					ClearSignalThread( signalNum_t signalnum, idThread *thread );
	bool					HasSignal( signalNum_t signalnum ) const;
	void					Signal( signalNum_t signalnum );
	void					SignalEvent( idThread *thread, signalNum_t signalnum );

	// gui
	void					TriggerGuis();
	bool					HandleGuiCommands( idEntity *entityGui, const char *cmds );
	virtual bool			HandleSingleGuiCommand( idEntity *entityGui, idLexer *src );

	// targets
	void					FindTargets();
	void					RemoveNullTargets();
	void					ActivateTargets( idEntity *activator ) const;

	// misc
	virtual void			Teleport( const idVec3 &amp;origin, const idAngles &amp;angles, idEntity *destination );
	bool					TouchTriggers() const;
	idCurve_Spline&lt;idVec3&gt; *GetSpline() const;
	virtual void			ShowEditingDialog();

	enum {
		EVENT_STARTSOUNDSHADER,
		EVENT_STOPSOUNDSHADER,
		EVENT_MAXEVENTS
	};

	// Called on clients in an MP game, does the actual interpolation for the entity.
	// This function will eventually replace ClientPredictionThink completely.
	virtual void			ClientThink( const int curTime, const float fraction, const bool predict );

	virtual void			ClientPredictionThink();
	virtual void			WriteToSnapshot( idBitMsg &amp;msg ) const;
	void					ReadFromSnapshot_Ex( const idBitMsg &amp;msg );
	virtual void			ReadFromSnapshot( const idBitMsg &amp;msg );
	virtual bool			ServerReceiveEvent( int event, int time, const idBitMsg &amp;msg );
	virtual bool			ClientReceiveEvent( int event, int time, const idBitMsg &amp;msg );

	void					WriteBindToSnapshot( idBitMsg &amp;msg ) const;
	void					ReadBindFromSnapshot( const idBitMsg &amp;msg );
	void					WriteColorToSnapshot( idBitMsg &amp;msg ) const;
	void					ReadColorFromSnapshot( const idBitMsg &amp;msg );
	void					WriteGUIToSnapshot( idBitMsg &amp;msg ) const;
	void					ReadGUIFromSnapshot( const idBitMsg &amp;msg );

	void					ServerSendEvent( int eventId, const idBitMsg *msg, bool saveEvent, lobbyUserID_t excluding = lobbyUserID_t() ) const;
	void					ClientSendEvent( int eventId, const idBitMsg *msg ) const;

	void					SetUseClientInterpolation( bool use ) { useClientInterpolation = use; }

	void					SetSkipReplication( const bool skip ) { fl.skipReplication = skip; }
	bool					GetSkipReplication() const { return fl.skipReplication; }
	bool					IsReplicated() const { return  GetEntityNumber() &lt; ENTITYNUM_FIRST_NON_REPLICATED; }

	void					CreateDeltasFromOldOriginAndAxis( const idVec3 &amp; oldOrigin, const idMat3 &amp; oldAxis );
	void					DecayOriginAndAxisDelta();
	uint32					GetPredictedKey() { return predictionKey; }
	void					SetPredictedKey( uint32 key_ ) { predictionKey = key_; }

	void					FlagNewSnapshot();

	idEntity*				GetTeamChain() { return teamChain; }

	// It is only safe to interpolate if this entity has received two snapshots.
	enum interpolationBehavior_t {
		USE_NO_INTERPOLATION,
		USE_LATEST_SNAP_ONLY,
		USE_INTERPOLATION
	};

	interpolationBehavior_t GetInterpolationBehavior() const { return interpolationBehavior; }
	unsigned int			GetNumSnapshotsReceived() const { return snapshotsReceived; }

protected:
	renderEntity_t			renderEntity;						// used to present a model to the renderer
	int						modelDefHandle;						// handle to static renderer model
	refSound_t				refSound;							// used to present sound to the audio engine

	idVec3					GetOriginDelta() const { return originDelta; }
	idMat3					GetAxisDelta() const { return axisDelta; }
	
private:
	idPhysics_Static		defaultPhysicsObj;					// default physics object
	idPhysics *				physics;							// physics used for this entity
	idEntity *				bindMaster;							// entity bound to if unequal NULL
	jointHandle_t			bindJoint;							// joint bound to if unequal INVALID_JOINT
	int						bindBody;							// body bound to if unequal -1
	idEntity *				teamMaster;							// master of the physics team
	idEntity *				teamChain;							// next entity in physics team
	bool					useClientInterpolation;				// disables interpolation for some objects (handy for weapon world models)
	int						numPVSAreas;						// number of renderer areas the entity covers
	int						PVSAreas[MAX_PVS_AREAS];			// numbers of the renderer areas the entity covers

	signalList_t *			signals;

	int						mpGUIState;							// local cache to avoid systematic SetStateInt

	uint32					predictionKey;						// Unique key used to sync predicted ents (projectiles) in MP.

	// Delta values that are set when the server or client disagree on where the render model should be. If this happens,
	// they resolve it through DecayOriginAndAxisDelta()
	idVec3					originDelta;
	idMat3					axisDelta;

	interpolationBehavior_t	interpolationBehavior;	
	unsigned int			snapshotsReceived;

private:
	void					FixupLocalizedStrings();

	bool					DoDormantTests();				// dormant == on the active list, but out of PVS

	// physics
							// initialize the default physics
	void					InitDefaultPhysics( const idVec3 &amp;origin, const idMat3 &amp;axis );
							// update visual position from the physics
	void					UpdateFromPhysics( bool moveBack );
							// get physics timestep
	virtual int				GetPhysicsTimeStep() const;

	// entity binding
	bool					InitBind( idEntity *master );		// initialize an entity binding
	void					FinishBind();					// finish an entity binding
	void					RemoveBinds();				// deletes any entities bound to this object
	void					QuitTeam();					// leave the current team

	void					UpdatePVSAreas();

	// events
	void					Event_GetName();
	void					Event_SetName( const char *name );
	void					Event_FindTargets();
	void					Event_ActivateTargets( idEntity *activator );
	void					Event_NumTargets();
	void					Event_GetTarget( float index );
	void					Event_RandomTarget( const char *ignore );
	void					Event_Bind( idEntity *master );
	void					Event_BindPosition( idEntity *master );
	void					Event_BindToJoint( idEntity *master, const char *jointname, float orientated );
	void					Event_Unbind();
	void					Event_RemoveBinds();
	void					Event_SpawnBind();
	void					Event_SetOwner( idEntity *owner );
	void					Event_SetModel( const char *modelname );
	void					Event_SetSkin( const char *skinname );
	void					Event_GetShaderParm( int parmnum );
	void					Event_SetShaderParm( int parmnum, float value );
	void					Event_SetShaderParms( float parm0, float parm1, float parm2, float parm3 );
	void					Event_SetColor( float red, float green, float blue );
	void					Event_GetColor();
	void					Event_IsHidden();
	void					Event_Hide();
	void					Event_Show();
	void					Event_CacheSoundShader( const char *soundName );
	void					Event_StartSoundShader( const char *soundName, int channel );
	void					Event_StopSound( int channel, int netSync );
	void					Event_StartSound( const char *soundName, int channel, int netSync );
	void					Event_FadeSound( int channel, float to, float over );
	void					Event_GetWorldOrigin();
	void					Event_SetWorldOrigin( idVec3 const &amp;org );
	void					Event_GetOrigin();
	void					Event_SetOrigin( const idVec3 &amp;org );
	void					Event_GetAngles();
	void					Event_SetAngles( const idAngles &amp;ang );
	void					Event_SetLinearVelocity( const idVec3 &amp;velocity );
	void					Event_GetLinearVelocity();
	void					Event_SetAngularVelocity( const idVec3 &amp;velocity );
	void					Event_GetAngularVelocity();
	void					Event_SetSize( const idVec3 &amp;mins, const idVec3 &amp;maxs );
	void					Event_GetSize();
	void					Event_GetMins();
	void					Event_GetMaxs();
	void					Event_Touches( idEntity *ent );
	void					Event_SetGuiParm( const char *key, const char *val );
	void					Event_SetGuiFloat( const char *key, float f );
	void					Event_GetNextKey( const char *prefix, const char *lastMatch );
	void					Event_SetKey( const char *key, const char *value );
	void					Event_GetKey( const char *key );
	void					Event_GetIntKey( const char *key );
	void					Event_GetFloatKey( const char *key );
	void					Event_GetVectorKey( const char *key );
	void					Event_GetEntityKey( const char *key );
	void					Event_RestorePosition();
	void					Event_UpdateCameraTarget();
	void					Event_DistanceTo( idEntity *ent );
	void					Event_DistanceToPoint( const idVec3 &amp;point );
	void					Event_StartFx( const char *fx );
	void					Event_WaitFrame();
	void					Event_Wait( float time );
	void					Event_HasFunction( const char *name );
	void					Event_CallFunction( const char *name );
	void					Event_SetNeverDormant( int enable );
	void					Event_SetGui( int guiNum, const char *guiName);
	void					Event_PrecacheGui( const char *guiName );
	void					Event_GetGuiParm(int guiNum, const char *key);
	void					Event_GetGuiParmFloat(int guiNum, const char *key);
	void					Event_GuiNamedEvent(int guiNum, const char *event);
};
					</code></pre>
					<aside class="notes">
						<p>Point out health field toward top: // FIXME: do all objects really need health?</p>
					</aside>
				</section>
				<section data-background="#158">
					<h1>Unity to the rescue</h1>
					<img src="img/unity.jpg" />
					<aside class="notes">
						<p>Just check off the list which components you want</p>
					</aside>
				</section>
				<section data-background="#101a26">
					<h1>Revised structure</h1>
					<ul class="blank">
						<li>idPlayer
						<ul class="blank">
							<li>idTransform</li>
							<li>idHealth</li>
							<li>idAnimatedModel</li>
							<li>idAnimator</li>
							<li>idRigidBody</li>
							<li>idBipedalCharacterController</li>
							<li>idPlayerController</li>
						</ul>
						</li>

						<li>idAFEntity_VehicleFourWheels
						<ul class="blank">
							<li>idTransform</li>
							<li>idAnimatedModel</li>
							<li>idRigidBody</li>
							<li>idFourWheelController</li>
						</ul>
						</li>

						<li>...</li>
					</ul>
					<aside class="notes">
						<p>Example: tack on a network sync component</p>
					</aside>
				</section>
				<section data-background="#185">
					<h1>Trick #3</h1>
					<p>In general, favor composition over inheritance</p>
					<aside class="notes">
						<ul>
							<li>One level of inheritance is okay</li>
							<li>Next: quick review</li>
						</ul>
					</aside>
				</section>
				<section data-background="#822">
					<h3>Why do we avoid globals (trick #1)?<br />Why is OOP better (trick #2)?<br />Why is composition even better (trick #3)?</h3>
					<aside class="notes">
						<p>Next: small detour before the big reveal</p>
					</aside>
				</section>
				<section data-background="#158">
					<h1>Let's talk about performance</h1>
				</section>
				<section data-background="#101a26">
					<h1>Which function is slower?</h1>
					<pre><code class="csharp">
double a(double x)
{
	return Math.sqrt(x);
}

static double[] data;
double b(int x)
{
	return data[x];
}
					</pre></code>
				</section>
				<section data-background="#158">
					<p>Hopefully both get compiled into roughly one instruction each</p>
					<p>a = some sort of sqrt instruction</p>
					<p>b = some sort of load instruction</p>
				</section>
				<section data-background="#822">
					<h1>Instruction latency</h1>
					<table>
						<tr><td>sqrtps</td><td>14 cycles</td></tr>
						<tr><td>movq</td><td>?</td></tr>
					</table>
					<small>
						<a href="http://www.intel.com/content/www/us/en/architecture-and-technology/64-ia-32-architectures-optimization-manual.html">
							intel.com/content/www/us/en/architecture-and-technology/64-ia-32-architectures-optimization-manual.html
						</a>
					</small>
				</section>
				<section data-background="#158">
					<h1>Where's the data?</h1>
					<table>
						<tr><td>Registers</td><td>~40 per core, sort of</td><td></td><td>0 cycles</td></tr>
						<tr><td>L1</td><td>32KB per core</td><td>64B line</td><td>4 cycles</td></tr>
						<tr><td>L2</td><td>256KB per core</td><td>64B line</td><td>11 cycles</td></tr>
						<tr><td>L3</td><td>6MB</td><td>64B line</td><td>40-75 cycles</td></tr>
						<tr><td>Main memory</td><td>8GB</td><td>4KB page</td><td>100-300 cycles</td></tr>
					</table>
				</section>
				<section id="l1" data-background="#822">
					<h1>L1</h1>
				</section>
				<section id="l2" data-background="#822">
					<h1>L2/sqrtps</h1>
				</section>
				<section id="l3" data-background="#822">
					<h1>L3</h1>
				</section>
				<section id="ram" data-background="#822">
					<h1>RAM</h1>
				</section>
				<section data-background="#185">
					<h1>Trick #4</h1>
					<p>Think about cache for huge performance gains</p>
					<img src="img/gainz.png" />
				</section>
				<section data-background="#158">
					<h1>The One Weird Trick</h1>
					<p class="fragment">Data first, not code first</p>
					<p class="fragment">Data-Oriented Design</p>
				</section>
				<section data-background="#822">
					<h1>Why should we avoid globals in certain cases?</h1>
					<p>(trick #1)</p>
					<p class="fragment">Data is not organized correctly</p>
				</section>
				<section data-background="#822">
					<h1>Why does object-oriented programming help?</h1>
					<p>(trick #2)</p>
					<p class="fragment">It helps you organize your data</p>
				</section>
				<section data-background="#822">
					<h1>Why is composition even better than OOP?</h1>
					<p>(trick #3)</p>
					<p class="fragment">It helps you organize even better!</p>
				</section>
				<section data-background="#822">
					<h1>Why does my code run faster when I line up data in memory?</h1>
					<p>(trick #4)</p>
					<p class="fragment">Even your CPU likes it when you organize your data better</p>
				</section>
				<section data-background="#158">
					<h1>Let's compare OOP and DOD</h1>
				</section>
				<section data-background="#101a26">
					<h1>OOP encapsulation</h1>
					<div class="fragment img">
						<img class="absolute" src="img/uml.svg" />
						<img class="fragment absolute" src="img/uml-encapsulation.svg" />
						<img class="fragment absolute" src="img/uml-encapsulation2.svg" />
					</div>
					<aside class="notes">
						<ul>
							<li>Fields private, only accessible by methods.</li>
							<li>Encapsulate data because that's the dangerous important part.</li>
							<li>Object guaranteed to work if you follow the contract.</li>
							<li>Theory: we could swap out data and it would still work.</li>
							<li>Could switch age from int to float.</li>
							<li>Code/behavior/contract first, data is almost irrelevant.</li>
						</ul>
					</aside>
				</section>
				<section data-background="#822">
					<img src="img/throne-of-lies.jpg" />
					<p>They're all interconnected</p>
					<aside class="notes">
						<ul>
							<li>Worst example: getters/setters</li>
							<li>Contract depends heavily on data. Age int/float example.</li>
							<li>Try changing the data representation, see what happens</li>
							<li>In theory, you could pull out one object from a project and use it somewhere else.</li>
							<li>In reality, encapsulation rarely works on the object level. More often at the system or library level.</li>
						</ul>
					</aside>
				</section>
				<section data-background="#158">
					TODO: illustrate system-level or library-level encapsulation.
					<aside class="notes">
						<ul>
							<li>Often want to encapsulate a system</li>
							<li>Don't waste time writing contracts between objects when they're naturally linked.</li>
						</ul>
					</aside>
				</section>
				<section data-background="#822">
					<h1>"But OOP helps us better model the world!"</h1>
					<aside class="notes">
						<ul>
							<li>"Think about bits and bytes like real-world objects."</li>
							<li>Not arguing that OOP is useless.</li>
							<li>The abstraction often doesn't match the real world, but people use it anyway.</li>
						</ul>
					</aside>
				</section>
				<section data-background="#101a26">
					<div class="img">
						<img class="absolute" src="img/types-behaviors1.svg" />
						<img class="fragment absolute" src="img/types-behaviors2.svg" />
						<img class="fragment absolute" src="img/types-behaviors3.svg" />
					</div>
					<aside class="notes">
						<ul>
							<li>Types: could be a struct; different than an object</li>
							<li>This abstraction can accomodate any program.</li>
							<li>Shoehorns behavior into types: Doom 3 net sync example.</li>
							<li>Some behaviors deal with multiple types; too bad</li>
							<li>End up creating new, empty types purely to contain behaviors.</li>
						</ul>
					</aside>
				</section>
				<section data-background="#822">
					<h1>Steve Yegge's Kingdom of Nouns</h1>
					<ul>
						<li>Service</li>
						<li>Manager</li>
						<li>Provider</li>
						<li>Factory</li>
					</ul>
					<aside class="notes">
						<ul>
							<li>Brian Will - Object-Oriented Programming is Bad</li>
							<li>Impossible to fit everything into OOP paradigm, so we create these to make it fit.</li>
						</ul>
					</aside>
				</section>
				<section data-background="#822">
					<h1>Example: messaging system</h1>
					<ul>
						<li class="fragment">Should a Message object <em>send()</em> itself?</li>
						<li class="fragment">Or should a Endpoint object <em>send()</em> it?</li>
						<li class="fragment">Or should a Connection object <em>transmit()</em> it?</li>
						<li class="fragment">Do we need a ConnectionFactory?</li>
					</ul>
					<p class="fragment">Made-up problems</p>
					<aside class="notes">
						<ul>
							<li>Scenario: interview question</li>
							<li>Not actually thinking about the real problem of sending messages, just thinking about how to shoehorn behaviors into types.</li>
							<li>Unnecessary; keep behavior and data separate.</li>
							<li>You SHOULD fail this interview</li>
						</ul>
					</aside>
				</section>
				<section data-background="#158">
					<h1>What you should be asking</h1>
					<ul>
						<li>How large are the messages?</li>
						<li>How often are we sending them?</li>
					</ul>
					<aside class="notes">
						<ul>
							<li>Interviewers want to know what questions you ask</li>
							<li>Bandwidth?</li>
							<li>How am I sending these? In-game? IPC? Network? Smoke signals?</li>
							<li>Latency?</li>
							<li>Queueing/storing?</li>
							<li>Reliability?</li>
							<li>Error handling?</li>
						</ul>
					</aside>
				</section>
                <section data-background="#185">
					<h1>Example: Doom 3</h1>
					<p>Let's look at Doom 3's update function</p>
					<aside class="notes">
						<ul>
							<li>What is an update function?</li>
							<li>Executes at 60 FPS, or 30 FPS in a bad game</li>
						</ul>
					</aside>
				</section>
				<section data-background="#101a26">
					<pre><code class="cpp">
for ( idEntity* ent = activeEntities.Next();
       ent != NULL;
       ent = ent-&gt;activeNode.Next() )
{
       if ( g_cinematic.GetBool() &amp;&amp; inCinematic &amp;&amp; !ent-&gt;cinematic )
       {
               ent-&gt;GetPhysics()-&gt;UpdateTime( time );
               continue;
       }
       timer_singlethink.Clear();
       timer_singlethink.Start();
       RunEntityThink( *ent, cmdMgr );
       timer_singlethink.Stop();
       ms = timer_singlethink.Milliseconds();
       if ( ms &gt;= g_timeentities.GetFloat() )
               Printf( "%d: entity '%s': %.1f ms\n", time, ent-&gt;name.c_str(), ms );
       num++;
}
					</code></pre>
					<p>Looks pretty clean and generic</p>
					<aside class="notes">
						<ul>
							<li>RunEntityThink probably calls a virtual function</li>
							<li>Great OOP design</li>
							<li>Can change entities without changing this loop</li>
							<li>Complexity encapsulated inside entities</li>
							<li>Could be update loop for almost any game</li>
						</ul>
					</aside>
				</section>
				<section data-background="#185">
					<h1>Questions</h1>
					<ul>
						<li>What is executing?</li>
						<li>In what order is it executing?</li>
						<li>Where is the data stored in memory?</li>
						<li>How would you parallelize this?</li>
					</ul>
					<img src="img/shrug.gif" class="fragment" />
					<aside class="notes">
						<ul>
							<li>Bad execution order leads to jitter</li>
							<li>Linked list - different sized entities scattered on the heap</li>
							<li>Cache is sad - example of single-byte-sized entity</li>
							<li>Can't parallelize - not sure what entities depend on each other</li>
						</ul>
					</aside>
				</section>
				<section data-background="#101a26">
					<h1>Compare to this</h1>
					<pre><code class="cpp">
for (int i = 0; i &lt; rigid_bodies.length; i++)
       rigid_bodies[i].update();

for (int i = 0; i &lt; ai_controllers.length; i++)
       ai_controllers[i].update();

// etc...
					</code></pre>
					<div class="fragment">
						<ul>
							<li>What is executing?</li>
							<li>In what order is it executing?</li>
							<li>Where is the data?</li>
							<li>How would you parallelize this?</li>
						</ul>
					</div>
					<aside class="notes">
						<ul>
							<li>Not encapsulated in OOP sense - if we change entities, have to change this update loop</li>
							<li>Cache - single-byte-sized component</li>
						</ul>
					</aside>
				</section>
				<section data-background="#185">
					<h1>Takeaway</h1>
					<ol>
						<li class="fragment">Data first, not code first.</li>
						<li class="fragment">Separate behavior and state.</li>
						<li class="fragment">Don't instinctively reach for OOP for every problem.</li>
					</ol>
				</section>
				<section data-background="#158">
					<h1>Disclaimers</h1>
					<ul>
						<li>Objects are still useful.</li>
						<li>Use the right tool for the right job.</li>
						<li>Hard and fast rules do not exist.</li>
					</ul>
				</section>
				<section data-background="#185">
					<h1>Thank you!</h1>
					<ul>
						<li>
							Slides<br />
							<a href="https://etodd.github.io/one-weird-trick">etodd.github.io/one-weird-trick</a>
						</li>
						<li>
							Article<br />
							<a href="http://etodd.io/2015/09/28/one-weird-trick-better-code/">etodd.io/2015/09/28/one-weird-trick-better-code</a>
						</li>
						<li>
							Mike Acton - Data-Oriented Design<br />
							<a href="https://www.youtube.com/watch?v=rX0ItVEVjHc">youtube.com/watch?v=rX0ItVEVjHc</a>
						</li>
						<li>
							Brian Will - Object-Oriented Programming is Bad<br />
							<a href="https://www.youtube.com/watch?v=QM1iUe6IofM">youtube.com/watch?v=QM1iUe6IofM</a>
						</li>
						<li>
							Casey Muratori - Semantic Compression<br />
							<a href="http://mollyrocket.com/casey/stream_0019.html">mollyrocket.com/casey/stream_0019.html</a>
						</li>
					</ul>
				</section>
			</div>
		</div>

		<script src="reveal.js/lib/js/head.min.js"></script>
		<script src="reveal.js/js/reveal.js"></script>
		<script>
			Reveal.initialize(
			{
				controls: false,
				progress: true,
				history: true,
				center: true,
				transition: 'slide',
				backgroundTransition: 'slide',
				transitionSpeed: 'superfast',
				dependencies:
				[
					{ src: 'reveal.js/plugin/highlight/highlight.js', async: false, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'reveal.js/plugin/notes/notes.js', async: false },
				],
			});

			if (window.location.search.match(/print-pdf/gi))
				$('head').append($('<link rel="stylesheet" type="text/css" href="reveal.js/css/print/pdf.css" />'));
		</script>
	</body>
</html>
